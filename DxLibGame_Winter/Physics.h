#pragma once
#include "Vector2.h"
#include <memory>
#include "MapConstants.h"
#include <array>
#include <list>

class kMapChip;

/// <summary>
/// 物理挙動をつかさどる
/// </summary>
class Physics
{
private:
	/// <summary>
	/// 加えられた力
	/// </summary>
	Vector2 m_addForce;
	Vector2 m_accel;
	Vector2 m_velocity;
	float m_weight;
	/// <summary>
	/// 物体の体積
	/// これを使って浮力を算出
	/// </summary>
	float m_volume;
	bool m_useConstantForce;
	// オブジェクトがどの向きにどれくらい押されているか
	std::list<Vector2> m_pushedForces;

	// 関数ポインタ使うか
	using UpdateState_t = Vector2 (Physics::*)();
	UpdateState_t m_updateState;
	std::array<UpdateState_t, static_cast<int>(MapConstants::Environment::kEnvNum)> m_stateArray = 
	{
		&Physics::WaterUpdate,
		&Physics::GroundUpdate,
	};

	// 水中時と地上時で関数を切り替える
	Vector2 WaterUpdate();
	Vector2 GroundUpdate();
public:
	Physics();
	// 必要な値を初期値に入れたコンストラクタ
	Physics(float weight, float volume);

	// この関数で、自分の持っているパラメータと、このフレームに与えられた力から
	// 自分の1フレームに動く距離を算出する。
	Vector2 Update();

	// 力を加える
	void AddForce(Vector2 force);

	/// 文字通り速度を返す
	Vector2 GetVel() const { return m_velocity; }

	/// <summary>
	/// 移動を止める
	/// これ以外で直接velocityをいじるのはできるだけやめよう
	/// </summary>
	void Stop() { m_velocity = Vector2::Zero(); }
	/// <summary>
	/// 重力と浮力のいざこざから離れたいときに
	/// </summary>
	void UseConstantForce(bool value) { m_useConstantForce = value; }

	// 与えられた列挙に対応した状態かどうかを返す
	bool CheckState (const MapConstants::Environment&) const;
	void ChangeState(const MapConstants::Environment&);
	void InvertState();
	MapConstants::Environment GetNowEnvironment() const;
	// 引数から摩擦力を算出して、移動時に考慮する
	// 性質上PhysicsのUpdateの前に実行しないと効果がないかも
	// 第一引数：押す力　第二引数：摩擦定数(0で摩擦なし、マイナスだと逆方向に摩擦が働く)
	void AddFrictionalForce(const Vector2& pushForce, const float& frictionFactor);
};