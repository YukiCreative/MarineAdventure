#include "Player.h"
#include <DxLib.h>
#include "Input.h"
#include "Physics.h"
#include "game.h"
#include "MapSystem.h"
#include "CircleCollider.h"
#include "BoxCollider.h"
#include "MapChip.h"
#include "Camera.h"

namespace
{
	// おテスト
	int kRaduis = 20;
}

Player::Player() :
	m_physics(std::make_shared<Physics>(1.0f, 1.0f))
{
	m_collider = std::make_shared<CircleCollider>(m_pos, kRaduis);
}

void Player::Update(std::shared_ptr<MapSystem> map)
{
	// 入力をとって、動く。
	Input& input = Input::GetInstance();

	Vector2 axis = input.GetInputAxis();

	// Aボタンでダッシュ状態へ(今後はアタックと同時にできないように)
	if (input.IsPressed(PAD_INPUT_1))
	{
		axis *= 1.5f;
	}
	// 仮
	m_physics->AddForce(axis * 0.01f);
	// Bボタンでアタック状態
	if (input.IsTrigger(PAD_INPUT_2))
	{
		m_physics->Stop();
		m_physics->AddForce(axis);
	}

	// 当たり判定の処理
	// マップチップ一つ一つと判定する
	for (auto& chip : map->GetMapCihps())
	{
		if (m_collider->CheckHit(chip->GetCollider()))
		{
			// マップチップの種類を見たいよね
			// マップチップと当たっていたら、自分の前回の速度の向きに応じて
		}
	}

	// 物理のUpdateは入力などで力を算出し終わった後に実行すること。
	// 物理演算+移動
	m_pos += m_physics->Update();
}

void Player::Draw(std::shared_ptr<Camera> camera) const
{
	Vector2 screenPos = camera->Capture(m_pos);
	DrawCircle(static_cast<int>(screenPos.x), static_cast<int>(screenPos.y), kRaduis, 0xff0000);
#if _DEBUG
	DrawFormatString(0, 15, 0x000000, "PlayerPos:x = %f, y = %f", m_pos.x, m_pos.y);
	DrawFormatString(0, 105, 0x000000, "screenPos:x = %f, y = %f", screenPos.x, screenPos.y);
#endif
}

Vector2 Player::GetVel() const
{
	return m_physics->GetVel();
}
